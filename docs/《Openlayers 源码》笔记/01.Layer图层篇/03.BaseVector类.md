---
title: BaseVector类
date: 2024-12-04 14:54:15
permalink: /pages/7c8d02/
categories:
  - 《Openlayers 源码》笔记
  - Layer图层篇
tags:
  -
author:
  name: 东流
  link: https://github.com/Jinuss
---

## 概述

本文主要介绍矢量图层的基类`BaseVector`类，在设置矢量图层时，通过选项传递的属性会成为图层对象的属性，并且这些属性会变得可观察，允许获取和设置其值。

## 源码剖析

`BaseVector`类继承自`Layer`类，其实现如下：

```js
class BaseVectorLayer extends Layer {
  constructor(options) {
    options = options ? options : {};

    const baseOptions = Object.assign({}, options);

    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    super(baseOptions);

    this.declutter_ = options.declutter ? String(options.declutter) : undefined;
    this.renderBuffer_ =
      options.renderBuffer !== undefined ? options.renderBuffer : 100;
    this.style_ = null;
    this.styleFunction_ = undefined;

    this.setStyle(options.style);
    this.updateWhileAnimating_ =
      options.updateWhileAnimating !== undefined
        ? options.updateWhileAnimating
        : false;

    this.updateWhileInteracting_ =
      options.updateWhileInteracting !== undefined
        ? options.updateWhileInteracting
        : false;
  }
  getDecluttter() {
    return this.declutter_;
  }
  getFetaures(pixel) {
    return super.getFeatures(pixel);
  }
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  getRenderOrder() {
    return this.get(Property.RENDER_ORDER);
  }
  getStyle() {
    return this.style_;
  }
  getStyleFunction() {
    return this.styleFunction_;
  }
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  renderDeclutter(frameState, layerState) {
    const declutterGroup = this.getDeclutter();
    if (declutterGroup in frameState.declutter === false) {
      frameState.declutter[declutterGroup] = new RBush(9);
    }
    this.getRenderer().renderDeclutter(frameState, layerState);
  }
  setRenderOrder() {
    this.set(Property.RENDER_ORDER, renderOrder);
  }
  setStyle(style) {
    this.style_ = style === undefined ? createDefaultStyle : style;
    const styleLike = toStyleLike(style);
    this.styleFunction_ =
      style === null ? undefined : toStyleFunction(styleLike);
    this.changed();
  }
}
```

### `BaseVector`类的构造函数

`BaseVector`类的构造函数接受一个参数对象`options`,然后赋值给变量`baseOptions`并将其传给父类`Layer`类，后面就是进行一些变量的初始化，调用了`this.setStyle`方法

- **`setStyle`方法**

`setStyle`方法实现如下：

```js
  setStyle(style) {
    this.style_ = style === undefined ? createDefaultStyle : style;
    const styleLike = toStyleLike(style);
    this.styleFunction_ =
      style === null ? undefined : toStyleFunction(styleLike);
    this.changed();
  }
```

`setStyle`方法主要用于设置`feature`的样式，其参数可以是一个`styleLike`类型，即`style Object`、数组`[style Object]`或者一个函数（返回值是一个`style Object`或者数组形式的`[style Object]`）。
若参数`style`是`undefined`,则会将`createDefaultStyle`函数赋值给`this.style_`。

- `createDefaultStyle`方法：它实际上就是一个`style Function`，接受两个参数要素`feature`和当前视图的分辨率`resolution`,其实现如下：

```js
export function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    const fill = new Fill({
      color: "rgba(255,255,255,0.4)",
    });
    const stroke = new Stroke({
      color: "#3399CC",
      width: 1.25,
    });
    defaultStyles = [
      new Style({
        image: new CircleStyle({
          fill: fill,
          stroke: stroke,
          radius: 5,
        }),
        fill: fill,
        stroke: stroke,
      }),
    ];
  }
  return defaultStyles;
}
```

`createDefaultStyle`方法就是返回一个`[style Object]`，`Style`类实例对象构成的数组；在一个矢量图层上添加一个`feature`，默认样式就是这个。

`setStyle`方法然后会调用`toStyleLike(style)`方法获取`styleLike`,`toStyleLike`方法就是将一系列不同形式的样式转为`style Functions`或者样式对象;若`styleLike`为`null`，则将`this.styleFunction_`赋值为`undefined`，否则调用`toStyleFunction(styleLike)`转为`style Function`

最后调用`this.changed()`方法

### `BaseVector`类的其它主要函数

- `getDeclutter`方法
## 总结
