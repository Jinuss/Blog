---
title: MousePosition鼠标位置控件源码分析
date: 2024-12-11 17:16:21
permalink: /pages/e00bdb/
categories:
  - 《Openlayers 源码》笔记
  - Control控件篇
tags:
  -
author:
  name: 东流
  link: https://github.com/Jinuss
---

## 概述

本文主要介绍 Openlayers 中的`MousePosition`鼠标位置控件，该控件会创建一个元素在页面的右上方用来实时显示鼠标光标的位置坐标。该控件在实际应用很有效，可以实时获取鼠标位置，但是一般控件元素都会自定义。

## 源码分析

`MousePosition`类是继承于`Control`类，关于`Control`类，可以参考这篇文章[Control 基类介绍](http://jinuss.github.io/blog/pages/644bd8/)。

### 
```js
class MousePosition extends Control {
  constructor(options) {
    options = options ? options : {};
    const element = document.createElement("div");
    element.className =
      options.className !== undefined ? options.className : "ol-mouse-position";

    super({
      element: element,
      render: options.render,
      target: options.target,
    });

    this.on;
    this.once;
    this.un;

    this.addChangeListener(PROJECTION, this.handleProjectionChanged_);

    if (options.coordinateFormat) {
      this.setCoordinateFormat(options.coordinateFormat);
    }
    if (options.projection) {
      this.setProjection(options.projection);
    }
    this.renderOnMouseOut_ = options.placeholder !== undefined;
    this.placeholder_ = this.renderOnMouseOut_ ? options.placeholder : "&#160;";
    this.renderedHTML_ = element.innerHTML;
    this.mapProjection_ = null;
    this.transform_ = null;
    this.wrapX_ = options.wrapX === false ? false : true;
  }

  handleProjectionChanged_() {
    this.transform_ = null;
  }

  getCoordinateFormat() {
    return this.get(COORDINATE_FORMAT);
  }
  handleMouseOut(event) {
    this.updateHTML_(null);
  }

  getProjection() {
    return this.get(PROJECTION);
  }

  handleMouseMove(event) {
    const map = this.getMap();
    this.updateHTML_(map.getEventPixel(event));
  }

  setMap(map) {
    super.setMap(map);
    if (map) {
      const viewport = map.getViewport();
      this.listenerKeys.push(
        listen(viewport, EventType.POINTERMOVE, this.handleMouseMove, this)
      );
      if (this.renderOnMouseOut_) {
        this.listenerKeys.push(
          listen(viewport, EventType.POINTEROUT, this.handleMouseOut, this)
        );
      }
      this.updateHTML_(null);
    }
  }

  setCoordinateFormat(format) {
    this.set(COORDINATE_FORMAT, format);
  }

  setProjection(projection) {
    this.set(PROJECTION, getProjection(projection));
  }

  updateHTML_(pixel) {
    let html = this.placeholder_;
    if (pixel && this.mapProjection_) {
      if (!this.transform_) {
        const projection = this.getProjection();
        if (projection) {
          this.transform_ = getTransformFromProjections(
            this.mapProjection_,
            projection
          );
        } else {
          this.transform_ = identityTransform;
        }
      }
      const map = this.getMap();
      const coordinate = map.getCoordinateFromPixelInternal(pixel);
      if (coordinate) {
        const userProjection = getUserProjection();
        if (userProjection) {
          this.transform_ = getTransformFromProjections(
            this.mapProjection_,
            userProjection
          );
        }
        this.transform_(coordinate, coordinate);
        if (this.wrapX_) {
          const projection =
            userProjection || this.getProjection() || this.mapProjection_;
          wrapX(coordinate, projection);
        }
        const coordinateFormat = this.getCoordinateFormat();
        if (coordinateFormat) {
          html = coordinateFormat(coordinate);
        } else {
          html = coordinate.toString();
        }
      }
    }
    if (!this.renderedHTML_ || html !== this.renderedHTML_) {
      this.element.innerHTML = html;
      this.renderedHTML_ = html;
    }
  }

  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      this.mapProjection_ = null;
    } else {
      if (this.mapProjection_ != frameState.viewState.projection) {
        this.mapProjection_ = frameState.viewState.projection;
        this.transform_ = null;
      }
    }
  }
}
```

## 总结
