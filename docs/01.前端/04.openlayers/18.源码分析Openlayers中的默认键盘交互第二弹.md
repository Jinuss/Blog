---
title: 源码分析Openlayers中的默认键盘交互第二弹
date: 2024-11-28 16:57:33
permalink: /pages/5f68f9/
categories:
  - 前端
  - openlayers
tags:
  -
author:
  name: 东流
  link: https://github.com/Jinuss
---

### 概述

在[源码分析 Openlayers 默认键盘交互实现](https://blog.csdn.net/m0_46281382/article/details/144107155)文中介绍了`KeyboardZoom`和 `KeyboardPan`的实现，它们都是继承`Interaction`类，封装了自己的`handleEvent`方法，该方法接受一个`mapBrowserEvent`参数，计算出地图视图的变化量，最后调用`view`的`animate`方法实现地图的缩放或平移。

本文将介绍 Openlayers 是如何实现`Interaction`类，以及键盘事件流的全过程即如何映射到 Openlayers 的自定义事件。

### 源码剖析

#### `defaultsInteractions`入口函数

当实例化一个地图，即`new Map(options)`时，会调用一个内部方法`createOptionsInternal`，该方法接受`options`参数经过一些处理，返回一个新的变量，如下：

```js
function createOptionsInternal(options) {
  /**.... **/
  let interactions;
  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new Collection(options.interactions.slice());
    } else {
      assert(
        typeof (/** @type {?} */ (options.interactions).getArray) ===
          "function",
        "Expected `interactions` to be an array or an `ol/Collection.js`"
      );
      interactions = options.interactions;
    }
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values,
  };
}
```

由此可知，如果参数`options`对象的`interactions`值为空，则`createOptionsInternal`内部不对其有任何处理，在`Map`的构造函数里会有如下的判断：

```js
const optionsInternal = createOptionsInternal(options);
this.interactions =
  optionsInternal.interactions ||
  defaultInteractions({
    onFocusOnly: true,
  });
```

在构造内部给`optionsInternal`变量赋值后，会判断它的`interactions`是否存在，如果不存在，则调用`defaultsInteractions`，这个方法就是决定了 Openlayers 采用默认的交互事件的入口函数。

#### `interactions`键盘事件的回调

构造函数`Map`内部会调用`this.addChangeListener(MapProperty.TARGET, this.handleTargetChanged_);`，这个注册后面会讲到，现在只需要知道，`map.target`变化会执行回调函数`handleTargetChanged_`

##### `handleTargetChanged_` 函数

`handleTargetChanged_`函数是`Map`类中的一个内部方法，主要用于监听到地图`target`的变化进行一些逻辑处理。在其中有如下一段逻辑：

```js
this.targetChangeHandlerKeys_ = [
  listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),
  listen(
    keyboardEventTarget,
    EventType.KEYPRESS,
    this.handleBrowserEvent,
    this
  ),
];
```

上述代码定义了一个数组`targetChangeHandlerKeys_`,数组项是调用了两次`listen()`方法，用于监听键盘按键的`keydown`和`keypress`事件。

##### `listen`方法

`listen`方法本质上就是`element.addEventListener`，其实现如下：

```js
export function listen(target, type, listener, thisArg, once) {
  if (once) {
    const originalListener = listener;
    /**
     * @this {typeof target}
     */
    listener = function () {
      target.removeEventListener(type, listener);
      originalListener.apply(thisArg ?? this, arguments);
    };
  } else if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  const eventsKey = {
    target: target,
    type: type,
    listener: listener,
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
```

###### `handleBrowserEvent`方法

`handleBrowserEvent`就是对应`listen`方法的第三个参数，执行的那个回调函数。其实现如下:

```js
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }
```

`browserEvent`就是原生的事件参数，而`MapBrowserEvent`将原生事件包装一层，多了一些和坐标地图有关的参数信息，它们对比如下图所示：

然后实例对象`mapBrowserEvent`就是会在各个`Interaction`类中`handleEvent`方法接收的参数，在`KeyboardPan`和`KeyboardZoom`的实现中有提到，最后调用`handleMapBrowserEvent`方法。

- **`handleMapBrowserEvent`**的核心代码，如下：

```js
if (this.dispatchEvent(mapBrowserEvent) !== false) {
  const interactionsArray = this.getInteractions().getArray().slice();
  for (let i = interactionsArray.length - 1; i >= 0; i--) {
    const interaction = interactionsArray[i];
    if (
      interaction.getMap() !== this ||
      !interaction.getActive() ||
      !this.getTargetElement()
    ) {
      continue;
    }
    const cont = interaction.handleEvent(mapBrowserEvent);
    if (!cont || mapBrowserEvent.propagationStopped) {
      break;
    }
  }
}
```

上述代码会去调用`dispatchEvent`，如果有返回值，就会遍历`interactions`,执行`interaction.handleEvent(mapBrowserEvent)`,即`KeyboardPan`或`KeyboardZoom`的`handleEvent`方法。

#### `dispatchEvent` 方法

`dispatchEvent`顾名思义就是派发事件，用于通知所有注册的事件`listener`。在弄清楚这个脉络清，我们先搞清楚`Map`类的继承关系。

#### `Map`类的继承

- **继承关系**：`Map`类继承`BaseObject`类，`BaseObject`类继承`Observable`类,`Observable`类继承`EventTarget`类.

#### 事件注册

在前面提到`this.addChangeListener(MapProperty.TARGET, this.handleTargetChanged_);`是注册了一个`listener`,`MapProperty.TARGET`就是实例化`Map`的参数`target`，对应地图的容器,
`Map`类中注册方法`addChangeListener`实际上就是`Observable`类中定义事件`addChangeListener`，如下：

```js
  addChangeListener(key, listener) {
    this.addEventListener(`change:${key}`, listener);
  }
```

可知，如果地图实例化时容器`target`是`#map`,则注册的事件类型就是`change:#map`。`addEventListener`方法实际上是在`EventTarget`中定义的，如下:

```js
  addEventListener(type, listener) {
    if (!type || !listener) {
      return;
    }
    const listeners = this.listeners_ || (this.listeners_ = {});
    const listenersForType = listeners[type] || (listeners[type] = []);
    if (!listenersForType.includes(listener)) {
      listenersForType.push(listener);
    }
  }
```

注册事件最后会放在`this.listeners_`变量中，类似于这种

```js
this.listeners_ = {
  "change:#map": this.handleTargetChanged_,
};
```
