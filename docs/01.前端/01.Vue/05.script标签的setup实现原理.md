---
title: script标签的setup实现原理
date: 2024-05-31 14:34:28
permalink: /pages/a924dx93/
categories:
  - 前端
  - Vue
tags:
  -
author:
  name: 东流
  link: https://github.com/Jinuss
---

### 概述

当 vue3 新建组件时，我们有两种选择选项式和组合式，如下所示

- 传统方式

  ```vue
  <template>
    <div>{{ greeting }}</div>
  </template>
  <script>
  import { ref } from "vue";
  export default {
    props: {
      name: String,
    },
    setup(props) {
      const greeting = ref(`Hello, ${props.name}!`);

      return {
        greeting,
      };
    },
  };
  </script>
  ```

- 组合式

```vue
<template>
  <div>{{ greeting }}</div>
</template>

<script setup>
import { ref } from "vue";

const props = defineProps({
  name: String,
});

const greeting = ref(`Hello, ${props.name}!`);
</script>
```

很明显，第二种方式 `Componsition API`的设计思想更加简洁，这样可以使用类似于`React Hooks`的方式编写 vue 组件。而`<script>` 标签中的自定义属性或关键字`setup`正是`Composition API`中的一个重要概念。
`setup`函数可以用于设置组件的初始状态、响应式数据、计算属性、定义事件交互等，当`<script>`标签使用`setup`关键字时，相当于也是在定义该 vue 组件的`setup`函数，并将其中的内容最终暴露给模板使用。

### `setup`详细介绍

#### `setup`原理

下面是`<script setup>`的一些内部原理：

- `Single File Component (SFC)` 解析：Vue 的编译器首先会解析 .vue 单文件组件，识别其中的`<script setup>` 部分，并将其视为特殊的语法块进行处理。
- 生成 `Setup` 函数：Vue 将 `<script setup>` 部分的代码转换为一个单独的 setup 函数。这个函数中包含了组件的状态（通过 `ref`、`reactive` 等函数定义的响应式数据）、计算属性、事件处理函数等。
- `Props` 和 `Context` 注入：`<script setup>` 中可以直接使用 props 和 context，而不需要显式地声明。Vue 在内部会自动将 `props` 和 `context` 注入到 `setup` 函数中，使开发者可以直接在其中使用这些变量。
- 编译优化：使用 `<script setup>` 语法可以帮助 Vue 进行更好的编译优化。由于所有的组件选项都被包装在一个 `setup` 函数中，Vue 可以更轻松地进行静态分析和优化，减少运行时的开销。
- 模块化引入：`<script setup>` 允许开发者在组件内部直接引入外部模块，而不需要像以前那样将其导入到组件的 `<script>` 标签中。这简化了组件的导入和使用。

#### 编译过程

当编译器识别到 vue 文件中`<script setup>`块时，它会将其中的代码视为特殊的语法块，会采取特定的步骤进行处理，如下

- 单文件组件解析：
  编译器首先会解析整个单文件组件（Single File Component，SFC），包括 `<template>`、`<script>` 和 `<style>` 部分。
  它会逐行扫描文件，查找特定的标记（例如 `<script setup>`）以确定每个部分的起始和结束。
  一旦找到了 `<script setup>` 标记，编译器就会开始处理其中的内容。
- 生成 `Setup` 函数：

编译器会将 `<script setup>` 部分的代码转换为一个单独的 `setup` 函数。这个函数包含了组件的状态、计算属性、事件处理函数等逻辑。
如果在 `<script setup>` 中使用了 `props` 和 `context`，编译器会自动将它们注入到 `setup` 函数中，使开发者可以直接在其中使用这些变量。
如果需要，编译器还会对代码进行必要的转换和优化，以提高性能和可读性。

- 分析变量依赖关系：

编译器会分析` setup` 函数中使用的响应式数据、计算属性和其他变量的依赖关系。
这样可以帮助编译器在组件更新时自动跟踪哪些部分需要重新渲染，从而实现更高效的渲染机制。

- 生成组件代码：

一旦 `setup` 函数和其相关的依赖关系被确定，编译器就会将它们与模板部分和其他组件选项（如 `props`、`methods` 等）整合起来，生成最终的组件代码。
这个过程可能会包括将模板编译成渲染函数、合并响应式数据、生成组件的生命周期钩子等步骤。

从中可以看出`<script setup>` 这种方式比直接使用`setup()`函数，从性能方面上来说要弱。

#### 编译过程

我们知道浏览器的引起是无法直接解析`.vue`文件，因此需要将`.vue`文件进行编译。vue3 的源码中有一个编译模块`@vue/compiler-sfc`专门用来编译`.vue`文件。
那么，`@vue/compiler-sfc`是如何编译的呢？这可能就取决于我们采用的脚手架，这个模块可以单独的被第三方插件或平台引用

#### `vite`中的`@vue/compiler-sfc`

基于`vite`脚手架创建的 vue3 项目时，会安装`@vitejs/plugin-vue`插件。在`vite`的默认配置文件中，会引用该插件，代码如下所示:

```js
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

export default defineConfig({
  plugins: [vue()],
});
```

当在终端运行`vite`命令时，操作会被`vite/dist/node/cli`捕获，进而调用`createServer`函数，这个函数是在`vite/dist/node/chunks`中定义，其返回了一个`async` 函数,如下所示

```js
async function _createServer(inlineConfig = {}, options) {
  const config = await resolveConfig(inlineConfig, "serve");
  // 省略
}
```

配置文件其实就是在`resolveConfig`中加载的


#### `webpack`中的`@vue/compiler-sfc`
