---
title: directive自定义指令
date: 2024-08-21 11:15:50
permalink: /pages/3dbs30/
categories:
  - 《Vue3源码》笔记
  - runtime-core
tags:
  -
author:
  name: 东流
  link: https://github.com/Jinuss
---

### 概述

`vue3` 中内置了很多丰富实用的指令，如`v-show`、`v-if/v-else`或`v-model`等，但是实际开发中可能我们还需要某些统一的处理，比如交互按钮的防抖，输入框的自动`focus`等待，这时我们就可以通过`vue3`的`directive`注册自定义指令。

### 指令

#### 指令钩子

`vue3`的自定义指令通常情况下是由一个包含类似组件生命周期钩子函数的对象，在`DOM`节点不同的时期，执行不同的钩子函数，而我们就可以在对应的钩子函数中接收到`DOM`节点、实例`instance`等待处理一些业务逻辑。

```js
const myDirective = {
  // 在绑定元素的 attribute 前
  // 或事件监听器应用前调用
  created(el, binding, vnode) {
    // 下面会介绍各个参数的细节
  },
  // 在元素被插入到 DOM 前调用
  beforeMount(el, binding, vnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都挂载完成后调用
  mounted(el, binding, vnode) {},
  // 绑定元素的父组件更新前调用
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都更新后调用
  updated(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount(el, binding, vnode) {},
  // 绑定元素的父组件卸载后调用
  unmounted(el, binding, vnode) {},
};
```

### 自定义防抖指令

#### 定义指令

一般地，我们只需要在 `mounted`中或`updated`中去处理，一个防抖指令如下:

```js
export default {
mounted(el, binding) {
  if (typeof binding.value !== 'function') {
    throw new Error("debounce指令的参数必须是一个函数，延时为1500ms")
    return
  }
  // 初始化时监听
  el.addEventListener('click', () => {
    if (!el.disabled) {
      el.disabled = true;
      const timer = setTimeout(() => {
        el.disabled = false;
        binding.value()
        clearTimeout(timer)
      }, 1000) // 1s间隔
    }
  });
},
```

上面的防抖指令`debounce`实现的就是`click`事件延迟一秒触发，当然时间间隔也可以当作参数传递，使用的时候:

#### 指令的注册

大多数情况还是会选择全局注册指令，挂载到 App 的全局上下文中去

```js
app.directive("debounce", debounce);
```

#### 使用指令

```vue
<el-button v-debounce="() => search(formRef)" type="primary">
  搜索
</el-button>
```

时间间隔使用参数传递，我们也可以这样写:

```vue
<el-button
  v-debounce="{ event: () => search(formRef), time: 1500 }"
  type="primary"
>
  搜索
</el-button>
```

指令对应修改如下：

```js
export default {
mounted(el, binding) {
  const {event,time}=binding.value;
  if (typeof event !== 'function') {
    throw new Error("debounce指令的参数必须是一个函数，延时为1500ms")
    return
  }
  // 初始化时监听
  el.addEventListener('click', () => {
    if (!el.disabled) {
      el.disabled = true;
      const timer = setTimeout(() => {
        el.disabled = false;
        event()
        clearTimeout(timer)
      }, time) // 1s间隔
    }
  });
},
```

#### 注意事项

官网上说:"只有当所需功能只能通过直接的 `DOM` 操作来实现时，才应该使用自定义指令。其他情况下应该尽可能地使用 v-bind 这样的内置指令来声明式地使用模板，这样更高效，也对服务端渲染更友好。” 毫无疑问，自定义指令是会带来性能的消耗，使用时应该有所权衡

### `directive` 源码分析

`vue3`使用自定义指令就三步：1.定义指令，构造特殊的对象 2.指令注册 3.指令绑定到`DOM`节点。

那`directive`的源码就从全局注册开始

#### 指令注册

当调用`app.directive`全局注册自定义指令时，会执行下面这个`directive`函数，将指令挂载到全局上下文`context`上去，所有的自定义指令保存在`context.directives`中。

```ts
  directive(name: string, directive?: Directive) {
        if (__DEV__) {
          validateDirectiveName(name) //判断是否是内部指令
        }

        if (!directive) {
          return context.directives[name] as any
        }
        if (__DEV__ && context.directives[name]) {
          warn(`Directive "${name}" has already been registered in target app.`)
        }
        context.directives[name] = directive
        return app
  },
```

#### 指令绑定

`transformElement` 接受两个参数 `node` 和 `context`。当 `node` 的属性 `props` 长度不为 0 时，就会调用 `buildProps` 函数，`buildProps` 函数顾名思义就是获取 `node` 上的属性进行相应操作，而针对指令，就会先判断是不是自定义指令，如果是自定义指令则将 `prop` 放进 `runtimeDirectives` ；如果不是自定义指令，则调用指令自身的 transform。
`buildProps` 函数调用完成后，返回一个名为 `propsBuildResult` 对象,而指令集都包含在 `propsBuildResult`.`directives` 中，然后调用 `createVNodeCall`, 在 `createVNodeCall` 中就会调用 `withDirectives` 方法，这个方法会将指令添加到 `VNode` 的 `dirs` 上，下面是它的实现：

```js
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    warn2(`withDirectives can only be used inside render functions.`);
    return vnode;
  }
  const instance =
    getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir,
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers,
      });
    }
  }
  return vnode;
}
```

#### 指令执行
